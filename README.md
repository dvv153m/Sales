# Sales
Book Sale

#### Summary ####

todo
1. Во все API сделать basic auth + в OrderClient и др. clients добавть header Authorization
2. Миграцию из Program вынести в Infrastructure
3. Рефачить объекты. Создать проект Contracts там Request, Response объекты
в Sales.Core папка Dto и Entity. 
OrderStatus должен быть один
4. Add FluentValudator на Request, Response objects
5. Тесты на бизнес логику. Правила добавления в корзину и оформления заказа
6. Отображение книг с картинками
7. SignalR
8. Доделать реализации репозиториев
9. Добавить API Gateway


Info:

2. Попадаем в метод контроллера. Метод контроллера принимает объект SomeRequest
мапим SomeRequest в доменный объект Some
вызываем метод сервиса или метод медиатора и передаем ему объект Some
в методе контроллере перехватываем пользовательские исключения


Todo:
генерация токена возможно перенести в infrastructure
вместо окончания Options OrderApiOptions   сделать Settings
библиотечка для генерации данных AutoFixture или AutoFaker
тесты  api
тесты бизнес логики
в OrderClient должен на вход приходить IOptions<> (спорный момент)

Общее:

Sales.Product.Api - для CRUD операций с товарами
Sales.Order.Api - для работы с заказами(для работы с корзиной корзины, создание заказа)
Sales.Promocode.Api - для авторизации по промокоду

API можно посмотреть через Swagger


1. Так как в задаче было сказано про возможность дальнейшего расширения и сопровождения продукта, я решил сделать структуру БД не только под книги, а под любые товары.
И второй момент о котором говорилось, про возможность горизонтального масштабирования с целью уменьшения нагрузки. Здесь это решается запуском дополнительных экземпляров 
сервисов (Sales.Promocode.Api, Sales.Product.Api, Sales.Order.Api).
Например, у нас много пользователей просматривают товары и мы заметили, что запрос на получение новой порции товаров занимает много времени,
то в этом случае можно поднять второй экземпляр Sales.Product.Api и это нам даст то, что мы сможем обрабатывать больше запросов в секунду.
2. В каждом Api реализован кеширующий декоратор репозитория (например ProductCacheDecoratorRepository), который снизит нагрузку на БД.
3. Отдельно выделенные Api позволяет нам сделать разные клиентские приложения (сайты, мобильное приложение + интеграция с другими системами).


Инструкция по запуску:

Должен быть установлен MS Sql Server.
Строки подключения к БД заданы в файле appsettings.Development.json в проектах: Sales.Promocode.Api, Sales.Product.Api, Sales.Order.Api.

1. Запустить проекты (в режиме Debug) Sales.Promocode.Api, Sales.Product.Api, Sales.Order.Api.
У каждого проекта будет создана своя БД. В БД Products будут добавлены 3 книги. В БД Promocodes будет добавлен промокод с админской ролью для того чтобы потом можно было добавлять/удалять/обновлять книги.
2. Далее запустить Sales.WebUI. Отобразится список книг.

Книги можно добавить в корзину, в интерфейсе не будет видно, что они туда добавлены (не успел сделать), но в БД Orders добавятся.

По реализации:
В качестве ORM используется Dapper.
Для миграции использовал FluentMigrator.
1. В Sales.WebUI используется cookie аутентификация в ней хранится промокод.
2. Не успел сделать авторизацию к Sales.Product.Api на добавление/обновление/удаление товаров. При запросе к API предполагал в хедере запроса передавать промокод.
В обработчике авторизации проверялся бы промокод на существование в БД и то что у этого промокода админская роль.
3. Бизнес правила по добавлению книг в корзину и оформление заказа реализованы ввиде паттерна Цепочка обязанностей, что позволяет легко добавлять/удалять правила.
4. В слое бизнес логики (Sales.Core.Services) выбрасываем пользовательские исключения, а сверху их перехватываем.
В проектах Api и Sales.WebUI добавлен глобальный обработчик исключений - для обработки не перехваченных исключений.


P.S. К сожалениюне не успел все реализовать: paging, живой счетчик оставшихся книг, изображение книг, валидацию моделей приходящих в контроллер.
Про живой счетчик я добавил бы интерфейс INotificationBook в репозиторий OrderRepository и в методе Add и AddProductToOrder
вызывал метод INotificationBook.Notify(productId, countBook), который бы отправлял эти данные в Sales.WebUI.


