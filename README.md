# Sales
Book Sale

#### Summary ####

Общее:

1. Так как в задаче было сказано про возможность дальнейшего расширения и сопровождения продукта я решил сделать структуру БД не только под книги, а под любые товары.
И второй момент о котором говорилось, про возможность горизонтального масштабирования с целью уменьшения нагрузки. Здесь это решается запуском дополнительных экземпляров 
сервисов (Sales.Promocode.Api, Sales.Product.Api, Sales.Order.Api)
Например, у нас много пользователей просматривают товары и мы заметили, что запрос на получение новой порции товара занимает много времени,
то в этом случае можно поднять второй экземпляр Sales.Product.Api и это нам даст то что мы сможем обрабатывать больше запросов в секунду.
2. В каждом Api реализован кеширующий декоратор репозитория(например ProductCacheDecoratorRepository), который снизит нагрузку на БД
3. Отдельно выделенные Api позволяет нам сделать разные клиентские приложения (сайты, мобильное приложение + интеграция с другими системами)


Инструкция по запуску:

Должен быть установлен MS Sql Server
Строки подключения к БД заданы в файле appsettings.Development.json в проектах: Sales.Promocode.Api, Sales.Product.Api, Sales.Order.Api

1. Запустить проекты(в режиме Debug) Sales.Promocode.Api, Sales.Product.Api, Sales.Order.Api
У каждого проекта будет создана своя БД. В БД Products будут добавлены 3 книги. В БД Promocodes будет добавлен промокод с админской ролью для того чтобы потом можно было добавлять/удалять/обновлять книги.
2. Далее запустить Sales.WebUI. Отобразится список книг.

Книги можно добавить в корзину, в интерфейсе не будет видно, что они туда добавлены(не успел сделать), но в БД Orders добавятся.

По реализации:
В качестве ORM используется Dapper
Для миграции использовал FluentMigrator
1. В Sales.WebUI используется cookie аутентификация в ней хранится промокод.
2. Не успел сделать авторизацию к Sales.Product.Api на добавление/обновление/удаление товаров. При запросе к API предполагал в хедере запроса передавать промокод.
В обработчике авторизации проверялся бы промокод на существование в БД и то что у этого промокода админская роль.
3. Бизнес правила по добавлению в книг в корзину и оформление заказа реализованы ввиде паттерна Цепочка обязанностей, что позволяет легко добавлять/удалять правила.
4. В слое бизнес логики (Sales.Core.Services) выбрасываем пользовательские исключения, а сверху их перехватываем.
В проектах Api и Sales.WebUI добавлен глобальный обработчик исключений - для обработки не перехваченных исключений


P.S. К сожалениюне не успел все реализовать: paging, живой счетчик оставшихся книг.
Про живой счетчик я добавил бы интерфейс INotificationBook в репозиторий OrderRepository и в методе Add и AddProductToOrder вызывал метод INotificationBook.Notify(productId, countBook), который бы отправлял эти данные в Sales.WebUI.

Basic moments:
- Viewing books and shopping cart, adding to cart is possible without authentication
- Sales.WebUI used Cookie Authentication

Не успел добавить
 - изображение книг
 - валидацию моделей которые приходят в API через FluentValidation
 - обновление счетчика оставшихся книг
 - авторизация API по промокоду. У промокода есть роль и преполагается, что совершать операции CRUD с товарами может пользователь, у которого промокод с админской ролью.
   при оформлении заказа можно у меня проверки на промокод. Их можно было оттуда вынести и в авторизацию добавить


   Инструкция по запуску. Запустить такой API потом другой. При запуске происходит миграция бд. 

   В бизнес логике генерируем пользовательские исключения
   В контроллерах их перехватывааем и возвращаем BadRequest
   в API перхватываются глобальный обработчик исключений другие исключения


   Используемые библиотеки и фреймворки:
Dapper, Fluent migrator

