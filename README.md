# Sales
Book Sale

#### Summary ####

Info:
1. проект Contracts содержит Request, Response

2. Папка Core проект Domain доменные объекты папка Objects or Models

2. Попадаем в метод контроллера. Метод контроллера принимает объект SomeRequest
мапим SomeRequest в доменный объект Some
вызываем метод сервиса или метод медиатора и передаем ему объект Some


Todo:
генерация токена возможно перенести в infrastructure
вместо окончания Options OrderApiOptions   сделать Settings
библиотечка для генерации данных AutoFixture или AutoFaker
тесты  api
тесты бизнес логики
в OrderClient должен на вход приходить IOptions<> (спорный момент)

Общее:

Sales.Product.Api - для CRUD операций с товарами
Sales.Order.Api - для работы с заказами(для работы с корзиной корзины, создание заказа)
Sales.Promocode.Api - для авторизации по промокоду

API можно посмотреть через Swagger


1. Так как в задаче было сказано про возможность дальнейшего расширения и сопровождения продукта, я решил сделать структуру БД не только под книги, а под любые товары.
И второй момент о котором говорилось, про возможность горизонтального масштабирования с целью уменьшения нагрузки. Здесь это решается запуском дополнительных экземпляров 
сервисов (Sales.Promocode.Api, Sales.Product.Api, Sales.Order.Api).
Например, у нас много пользователей просматривают товары и мы заметили, что запрос на получение новой порции товаров занимает много времени,
то в этом случае можно поднять второй экземпляр Sales.Product.Api и это нам даст то, что мы сможем обрабатывать больше запросов в секунду.
2. В каждом Api реализован кеширующий декоратор репозитория (например ProductCacheDecoratorRepository), который снизит нагрузку на БД.
3. Отдельно выделенные Api позволяет нам сделать разные клиентские приложения (сайты, мобильное приложение + интеграция с другими системами).


Инструкция по запуску:

Должен быть установлен MS Sql Server.
Строки подключения к БД заданы в файле appsettings.Development.json в проектах: Sales.Promocode.Api, Sales.Product.Api, Sales.Order.Api.

1. Запустить проекты (в режиме Debug) Sales.Promocode.Api, Sales.Product.Api, Sales.Order.Api.
У каждого проекта будет создана своя БД. В БД Products будут добавлены 3 книги. В БД Promocodes будет добавлен промокод с админской ролью для того чтобы потом можно было добавлять/удалять/обновлять книги.
2. Далее запустить Sales.WebUI. Отобразится список книг.

Книги можно добавить в корзину, в интерфейсе не будет видно, что они туда добавлены (не успел сделать), но в БД Orders добавятся.

По реализации:
В качестве ORM используется Dapper.
Для миграции использовал FluentMigrator.
1. В Sales.WebUI используется cookie аутентификация в ней хранится промокод.
2. Не успел сделать авторизацию к Sales.Product.Api на добавление/обновление/удаление товаров. При запросе к API предполагал в хедере запроса передавать промокод.
В обработчике авторизации проверялся бы промокод на существование в БД и то что у этого промокода админская роль.
3. Бизнес правила по добавлению книг в корзину и оформление заказа реализованы ввиде паттерна Цепочка обязанностей, что позволяет легко добавлять/удалять правила.
4. В слое бизнес логики (Sales.Core.Services) выбрасываем пользовательские исключения, а сверху их перехватываем.
В проектах Api и Sales.WebUI добавлен глобальный обработчик исключений - для обработки не перехваченных исключений.


P.S. К сожалениюне не успел все реализовать: paging, живой счетчик оставшихся книг, изображение книг, валидацию моделей приходящих в контроллер.
Про живой счетчик я добавил бы интерфейс INotificationBook в репозиторий OrderRepository и в методе Add и AddProductToOrder
вызывал метод INotificationBook.Notify(productId, countBook), который бы отправлял эти данные в Sales.WebUI.


