# Sales
Book Sale

#### Summary ####

Общее:

1. Так как в задаче было сказано про возможность дальнейшего расширения и сопровождения продукта, я решил сделать структуру БД не только под книги, а под любые товары.
И второй момент о котором говорилось, про возможность горизонтального масштабирования с целью уменьшения нагрузки. Здесь это решается запуском дополнительных экземпляров 
сервисов (Sales.Promocode.Api, Sales.Product.Api, Sales.Order.Api).
Например, у нас много пользователей просматривают товары и мы заметили, что запрос на получение новой порции товаров занимает много времени,
то в этом случае можно поднять второй экземпляр Sales.Product.Api и это нам даст то, что мы сможем обрабатывать больше запросов в секунду.
2. В каждом Api реализован кеширующий декоратор репозитория (например ProductCacheDecoratorRepository), который снизит нагрузку на БД.
3. Отдельно выделенные Api позволяет нам сделать разные клиентские приложения (сайты, мобильное приложение + интеграция с другими системами).


Инструкция по запуску:

Должен быть установлен MS Sql Server.
Строки подключения к БД заданы в файле appsettings.Development.json в проектах: Sales.Promocode.Api, Sales.Product.Api, Sales.Order.Api.

1. Запустить проекты (в режиме Debug) Sales.Promocode.Api, Sales.Product.Api, Sales.Order.Api.
У каждого проекта будет создана своя БД. В БД Products будут добавлены 3 книги. В БД Promocodes будет добавлен промокод с админской ролью для того чтобы потом можно было добавлять/удалять/обновлять книги.
2. Далее запустить Sales.WebUI. Отобразится список книг.

Книги можно добавить в корзину, в интерфейсе не будет видно, что они туда добавлены (не успел сделать), но в БД Orders добавятся.

По реализации:
В качестве ORM используется Dapper.
Для миграции использовал FluentMigrator.
1. В Sales.WebUI используется cookie аутентификация в ней хранится промокод.
2. Не успел сделать авторизацию к Sales.Product.Api на добавление/обновление/удаление товаров. При запросе к API предполагал в хедере запроса передавать промокод.
В обработчике авторизации проверялся бы промокод на существование в БД и то что у этого промокода админская роль.
3. Бизнес правила по добавлению книг в корзину и оформление заказа реализованы ввиде паттерна Цепочка обязанностей, что позволяет легко добавлять/удалять правила.
4. В слое бизнес логики (Sales.Core.Services) выбрасываем пользовательские исключения, а сверху их перехватываем.
В проектах Api и Sales.WebUI добавлен глобальный обработчик исключений - для обработки не перехваченных исключений.


P.S. К сожалениюне не успел все реализовать: paging, живой счетчик оставшихся книг, изображение книг, валидацию моделей приходящих в контроллер.
Про живой счетчик я добавил бы интерфейс INotificationBook в репозиторий OrderRepository и в методе Add и AddProductToOrder
вызывал метод INotificationBook.Notify(productId, countBook), который бы отправлял эти данные в Sales.WebUI.

